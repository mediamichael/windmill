/**
 * Flowtype definitions for dist/sugiyama/index.d.ts
 * Generated by Flowgen from a Typescript Definition
 * @flow
 */
// see https://gist.github.com/thecotne/6e5969f4aaf8f253985ed36b30ac9fe0
type $FlowGen$If<X: boolean, Then, Else = empty> = $Call<
  ((true, Then, Else) => Then) & ((false, Then, Else) => Else),
  X,
  Then,
  Else
>;

type $FlowGen$Assignable<A, B> = $Call<
  ((...r: [B]) => true) & ((...r: [A]) => false),
  A
>;

import { Dag, DagNode } from "../dag";
import { Up } from "../utils";
import { CoordNodeSizeAccessor, CoordOperator } from "./coord";
import { DefaultSimplexOperator as DefaultCoord } from "./coord/simplex";
import { DecrossOperator } from "./decross";
import { DefaultTwoLayerOperator as DefaultTwoLayer } from "./decross/two-layer";
import { LayeringOperator } from "./layering";
import { DefaultSimplexOperator as DefaultLayering } from "./layering/simplex";
import { SugiNode } from "./utils";

/**
 * [object Object],[object Object],[object Object]
 */
export interface SugiyamaInfo {
  /**
   * total width after layout
   */
  width: number;

  /**
   * total height after layout
   */
  height: number;
}
/**
 * [object Object],[object Object],[object Object]
 */
export interface NodeSizeAccessor<NodeDatum = empty, LinkDatum = empty> {
  (node?: DagNode<NodeDatum, LinkDatum>): [number, number];
}
/**
 * [object Object],[object Object],[object Object],[object Object],[object Object]
 */
export interface SugiNodeSizeAccessor<NodeDatum = empty, LinkDatum = empty> {
  (node: SugiNode<NodeDatum, LinkDatum>): [number, number];
}
/**
 * the node datum of a node size accessor
 */
export type NsNodeDatum<NS: NodeSizeAccessor<>> = $FlowGen$If<
  $FlowGen$Assignable<NS, NodeSizeAccessor<N, empty>>,
  N,
  empty
>;
/**
 * the link datum of a node size accessor
 */
export type NsLinkDatum<NS: NodeSizeAccessor<>> = $FlowGen$If<
  $FlowGen$Assignable<NS, NodeSizeAccessor<empty, L>>,
  L,
  empty
>;
/**
 * [object Object],[object Object],[object Object],[object Object],[object Object]
 */
export type WrappedNodeSizeAccessor<NodeSize: NodeSizeAccessor<>> = {
  /**
   * the underling node size
   */
  wrapped: NodeSize,
  ...
} & SugiNodeSizeAccessor<NsNodeDatum<NodeSize>, NsLinkDatum<NodeSize>>;

/**
 * [object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object]
 */
declare export function wrapNodeSizeAccessor<
  N,
  L,
  NS: NodeSizeAccessor<N, L>
>(acc: { ...NS, ...NodeSizeAccessor<N, L> }): {
  ...WrappedNodeSizeAccessor<NS>,
  ...SugiNodeSizeAccessor<N, L>,
};

/**
 * sugiyama operators
 */
export interface Operators<N = empty, L = empty> {
  /**
   * layering operator
   */
  layering: LayeringOperator<N, L>;

  /**
   * decross operator
   */
  decross: DecrossOperator<N, L>;

  /**
   * coord operator
   */
  coord: CoordOperator<N, L>;

  /**
   * sugi node size operator
   */
  sugiNodeSize: SugiNodeSizeAccessor<N, L>;

  /**
   * node size operator
   */
  nodeSize: NodeSizeAccessor<N, L> | null;
}
/**
 * the typed dag of a set of operators
 */
export type OpsDag<Ops: Operators<>> = $FlowGen$If<
  $FlowGen$Assignable<Ops, Operators<N, L>>,
  Dag<N, L>,
  Dag<empty, empty>
>;
/**
 * [object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object]
 * @remarks If one wants even more control over the algorithm, each step is broken down
 * in the source code and can be achieved by calling an exported utility
 * function. If one wants to call certain pieces incrementally, or adjust how
 * things are called, it's recommended to look at the source and call each
 * component function successively.
 * @example <img alt="Sugiyama example" src="media://sugi-simplex-opt-quad.png" width="400">
 * @example ```typescript
 * const data = [["parent", "child"], ...];
 * const create = connect();
 * const dag = create(data);
 * const layout = sugiyama();
 * const { width, height } = layout(dag);
 * for (const node of dag) {
 *   console.log(node.x, node.y);
 * }
 * ```
 * @example This example highlights tweaking several aspects of dag rendering
 * ```typescript
 * const data = [["parent", "child"], ...];
 * const create = connect();
 * const dag = create(data);
 * const layout = sugiyama()
 *   .nodeSize(n => n === undefined ? [0, 0] : [n.data.id.length, 2])
 *   .coord(greedy());
 * const { width, height } = layout(dag);
 * for (const node of dag) {
 *   console.log(node.x, node.y);
 * }
 * ```
 */
export interface SugiyamaOperator<Ops: Operators<> = Operators<>> {
  /**
   * [object Object],[object Object],[object Object]
   */
  (dag: OpsDag<Ops>): SugiyamaInfo;

  /**
   * [object Object],[object Object],[object Object],[object Object],[object Object]
   */
  layering<NewLayering: LayeringOperator>(layer: NewLayering): SugiyamaOperator<
    Up<
      Ops,
      {
        /**
         * new layering
         */
        layering: NewLayering,
        ...
      }
    >
  >;

  /**
   * [object Object],[object Object],[object Object]
   */
  layering(): $PropertyType<Ops, "layering">;

  /**
   * [object Object],[object Object],[object Object],[object Object],[object Object]
   */
  decross<NewDecross: DecrossOperator>(dec: NewDecross): SugiyamaOperator<
    Up<
      Ops,
      {
        /**
         * new decross
         */
        decross: NewDecross,
        ...
      }
    >
  >;

  /**
   * [object Object],[object Object],[object Object]
   */
  decross(): $PropertyType<Ops, "decross">;

  /**
   * [object Object],[object Object],[object Object],[object Object],[object Object]
   */
  coord<NewCoord: CoordOperator>(crd: NewCoord): SugiyamaOperator<
    Up<
      Ops,
      {
        /**
         * new coord
         */
        coord: NewCoord,
        ...
      }
    >
  >;

  /**
   * [object Object],[object Object],[object Object]
   */
  coord(): $PropertyType<Ops, "coord">;

  /**
   * [object Object],[object Object],[object Object]
   */
  size(sz: [number, number] | null): SugiyamaOperator<Ops>;

  /**
   * Get the current layout size.
   */
  size(): null | [number, number];

  /**
   * [object Object],[object Object],[object Object]
   * @remarks When overriding, make sure you handle the case where the node is
   * undefined. Failure to do so may result in unexpected layouts.
   */
  nodeSize<NewNodeSize: NodeSizeAccessor<>>(acc: NewNodeSize): SugiyamaOperator<
    Up<
      Ops,
      {
        /**
         * new node size
         */
        nodeSize: NewNodeSize,

        /**
         * new wrapped sugi node size
         */
        sugiNodeSize: WrappedNodeSizeAccessor<NewNodeSize>,
        ...
      }
    >
  >;

  /**
   * [object Object],[object Object],[object Object]
   */
  nodeSize(): $PropertyType<Ops, "nodeSize">;

  /**
   * [object Object],[object Object],[object Object],[object Object],[object Object]
   */
  sugiNodeSize<NewSugiNodeSize: SugiNodeSizeAccessor<>>(
    sz: NewSugiNodeSize
  ): SugiyamaOperator<
    Up<
      Ops,
      {
        /**
         * new sugi node size
         */
        sugiNodeSize: NewSugiNodeSize,

        /**
         * no node size
         */
        nodeSize: null,
        ...
      }
    >
  >;

  /**
   * [object Object],[object Object],[object Object],[object Object],[object Object]
   */
  sugiNodeSize(): $PropertyType<Ops, "sugiNodeSize">;
}
/**
 * [object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object]
 */
declare export function cachedNodeSize<N, L>(
  nodeSize: SugiNodeSizeAccessor<N, L>,
  check?: boolean
): [CoordNodeSizeAccessor<N, L>, CoordNodeSizeAccessor<N, L>];

/**
 * [object Object],[object Object],[object Object]
 */
declare export function coordVertical<N, L>(
  layers: $ReadOnlyArray<$ReadOnlyArray<SugiNode<N, L>>>,
  size: CoordNodeSizeAccessor<N, L>
): number;

/**
 * default node size
 */
export type DefaultNodeSizeAccessor = NodeSizeAccessor<mixed, mixed>;
/**
 * default sugiyama operator
 */
export type DefaultSugiyamaOperator = SugiyamaOperator<{
  /**
   * default layering
   */
  layering: DefaultLayering,

  /**
   * default decross
   */
  decross: DefaultTwoLayer,

  /**
   * default coord
   */
  coord: DefaultCoord,

  /**
   * wrapped default node size
   */
  sugiNodeSize: WrappedNodeSizeAccessor<DefaultNodeSizeAccessor>,

  /**
   * default node size
   */
  nodeSize: DefaultNodeSizeAccessor,
  ...
}>;
/**
 * [object Object],[object Object],[object Object]
 * @example ```typescript
 * const dag = hierarchy()(...);
 * const layout = sugiyama().nodeSize(d => d === undefined ? [0, 0] : [d.width, d.height]);
 * layout(dag);
 * for (const node of dag) {
 *   console.log(node.x, node.y);
 * }
 * ```
 */
declare export function sugiyama(...args: empty[]): DefaultSugiyamaOperator;
