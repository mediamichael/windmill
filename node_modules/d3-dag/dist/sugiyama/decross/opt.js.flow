/**
 * Flowtype definitions for dist/sugiyama/decross/opt.d.ts
 * Generated by Flowgen from a Typescript Definition
 * @flow
 */
import { DecrossOperator } from ".";

/**
 * What size of dags to error on
 *
 * Modifying this is probably a bad idea unless you know what you're doing.
 *
 * Optimally decrossing a dag can be prohibitively expensive. As a result, if
 * you try to decross any dag that is heuristically determined to be too big,
 * this will raise an error. Modifying how large graphs are handled will allow
 * you to override these heuristic limits, but is probably unwise.
 */
export type LargeHandling = "small" | "medium" | "large";
/**
 * [object Object],[object Object],[object Object],[object Object],[object Object]
 */
export type OptOperator = {
  /**
   * [object Object],[object Object],[object Object]
   */
  large(val: LargeHandling): OptOperator,

  /**
   * Get the current large graph handling value.
   */
  large(): LargeHandling,

  /**
   * Set whether to also minimize distance between nodes that share a parent /
   * child
   *
   * This adds more variables and constraints, and so will make the decrossing
   * step take longer, but will likely produce a better layout as nodes that
   * share common parents or children will be put closer together if it doesn't
   * affect the number of crossings. (default: false)
   */
  dist(val: boolean): OptOperator,

  /**
   * get whether the current layout minimized distance
   */
  dist(): boolean,
  ...
} & DecrossOperator<mixed, mixed>;

/**
 * [object Object],[object Object],[object Object],[object Object],[object Object]
 */
declare export function opt(...args: empty[]): OptOperator;
