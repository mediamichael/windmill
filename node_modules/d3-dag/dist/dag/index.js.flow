/**
 * Flowtype definitions for dist/dag/index.d.ts
 * Generated by Flowgen from a Typescript Definition
 * @flow
 */
/**
 * [object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object]
 * @packageDocumentation
 */
/**
 * All available styles of node iteration.
 */
export type IterStyle = "depth" | "breadth" | "before" | "after";
/**
 * a control point for a link
 */
export interface Point {
  /**
   * the x coordinate of the point
   */
  +x: number;

  /**
   * the y coordinate of the point
   */
  +y: number;
}
/**
 * A link between nodes, with attached information
 */
export interface DagLink<NodeDatum = mixed, LinkDatum = mixed> {
  /**
   * The dag node this link comes from
   */
  +source: DagNode<NodeDatum, LinkDatum>;

  /**
   * The dag node this link goes to
   */
  +target: DagNode<NodeDatum, LinkDatum>;

  /**
   * Arbitrary data attached to this link
   */
  +data: LinkDatum;

  /**
   * Points for how to render this node in a layout
   *
   * The property itself is read only, but the list is mutable to update or
   * changes points as necessary.
   */
  +points: Point[];

  /**
   * If the link had to be reversed to handle cycles, this will be true
   */
  +reversed: boolean;
}
/**
 * the callback for sum
 */
export interface SumCallback<NodeDatum, LinkDatum> {
  (node: DagNode<NodeDatum, LinkDatum>, index: number): number;
}
/**
 * [object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object]
 */
export type Dag<NodeDatum = mixed, LinkDatum = mixed> = {
  /**
   * @internal this is unused, but necessary for typescript to type check
   */
  __sentinel__?: NodeDatum,

  /**
   * Return an iterator over the dag's roots
   *
   * A root is a node without parents. If a dag has multiple roots, this will
   * return more than one object, if this represents a single node, then only
   * that node will be returned.
   */
  iroots(): Iterable<DagNode<NodeDatum, LinkDatum>>,

  /**
   * [object Object],[object Object],[object Object]
   */
  roots(): DagNode<NodeDatum, LinkDatum>[],

  /**
   * [object Object],[object Object],[object Object],[object Object],[object Object]
   */
  idescendants(style?: IterStyle): Iterable<DagNode<NodeDatum, LinkDatum>>,

  /**
   * [object Object],[object Object],[object Object]
   */
  descendants(style?: IterStyle): DagNode<NodeDatum, LinkDatum>[],

  /**
   * [object Object],[object Object]
   */
  ilinks(): Iterable<DagLink<NodeDatum, LinkDatum>>,

  /**
   * [object Object],[object Object],[object Object],[object Object],[object Object]
   */
  links(): DagLink<NodeDatum, LinkDatum>[],

  /**
   * Count the number of nodes in the dag
   */
  size(): number,

  /**
   * Compute values over the dag
   *
   * Provide a callback that computes a number for each node, then set a node's
   * `value` to the sum of this number for this node and all of its
   * descendants. Note, if another node is a child via two separate paths, that
   * child's value will only factor into this node's value once.
   */
  sum(callback: SumCallback<NodeDatum, LinkDatum>): this,

  /**
   * Set the value of each node to be the number of leaves beneath the node.
   * If this node is a leaf, its value is one.
   */
  count(): this,

  /**
   * Assign each node a value equal to its longest distance from a root.
   */
  height(): this,

  /**
   * Assign each node a value equal to its longest distance to a leaf.
   */
  depth(): this,

  /**
   * Split a dag into connected components
   *
   * Returns an iterable over each connected component as a new dag.
   */
  isplit(): Iterable<Dag<NodeDatum, LinkDatum>>,

  /**
   * [object Object],[object Object],[object Object]
   */
  split(): Dag<NodeDatum, LinkDatum>[],

  /**
   * Return true if every node in the dag is reachable from every other.
   */
  connected(): boolean,

  /**
   * Return true if at least one node in this dag has multiple lints to the same child.
   *
   * All support for multidags is in beta as testing that multidags don't cause
   * unexpected bugs is not easy to measure.
   * @beta
   */
  multidag(): boolean,
  ...
} & Iterable;

/**
 * A node in a dag
 *
 * All methods inherited from dag apply as if this node were the sole root of
 * the dag. In addition, nodes have several properties that can be set and read.
 * There are also methods to access this nodes children and links.
 */
export type DagNode<NodeDatum = mixed, LinkDatum = mixed> = {
  /**
   * the data backing this node
   */
  +data: NodeDatum,

  /**
   * a generic value written to by some functions
   */
  value?: number,

  /**
   * if the dag is laidout, this is the x position of the node
   */
  x?: number,

  /**
   * if the dag is laidout, this is the y position of the node
   */
  y?: number,

  /**
   * Return the number of unique child nodes
   */
  nchildren(): number,

  /**
   * Return the number of child links
   */
  nchildLinks(): number,

  /**
   * Return the number of links to a child node
   *
   * For memory efficiency reasons behavior for non-child nodes is undefined,
   * but for consistency currently all non-child nodes will return 1.
   */
  nchildLinksTo(node: DagNode<NodeDatum, LinkDatum>): number,

  /**
   * Return an iterable over this node's unique child nodes
   */
  ichildren(): Iterable<DagNode<NodeDatum, LinkDatum>>,

  /**
   * Return an array of this node's unique child nodes
   */
  children(): DagNode<NodeDatum, LinkDatum>[],

  /**
   * Return an iterable over this node's unique child nodes and the number of links to them
   */
  ichildrenCounts(): Iterable<[DagNode<NodeDatum, LinkDatum>, number]>,

  /**
   * Return an array of this node's unique child nodes and the number of links to them
   */
  childrenCounts(): [DagNode<NodeDatum, LinkDatum>, number][],

  /**
   * Return an iterator of links between this node and its children
   *
   * The order of links is guaranteed to not change between iterations.
   */
  ichildLinks(): Iterable<DagLink<NodeDatum, LinkDatum>>,

  /**
   * Returns an array of links between this node and its children
   *
   * The order of links is guaranteed to not change between iterations.
   */
  childLinks(): DagLink<NodeDatum, LinkDatum>[],
  ...
} & Dag<NodeDatum, LinkDatum>;
