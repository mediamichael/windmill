/**
 * Flowtype definitions for dist/dag/create.d.ts
 * Generated by Flowgen from a Typescript Definition
 * @flow
 */
// see https://gist.github.com/thecotne/6e5969f4aaf8f253985ed36b30ac9fe0
type $FlowGen$If<X: boolean, Then, Else = empty> = $Call<
  ((true, Then, Else) => Then) & ((false, Then, Else) => Else),
  X,
  Then,
  Else
>;

type $FlowGen$Assignable<A, B> = $Call<
  ((...r: [B]) => true) & ((...r: [A]) => false),
  A
>;

import { Dag } from ".";
import { Up } from "../utils";

/**
 * *********
 * General *
 * *********
 */
/**
 * [object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object]
 */
export interface IdOperator<Datum = empty> {
  (d: Datum, i: number): string;
}
/**
 * *********
 * Connect *
 * *********
 */
/**
 * An operator that creates node data from an id
 *
 * The index passed in is the edge index where the id is first seen.
 */
export interface IdNodeDatumOperator<D = mixed> {
  (id: string, index: number): D;
}
/**
 * [object Object],[object Object]
 */
export interface ConnectDatum {
  /**
   * the id
   */
  id: string;
}
/**
 * [object Object],[object Object]
 */
export interface ConnectOperators<N = mixed, L = empty> {
  /**
   * the source id operator
   */
  sourceId: IdOperator<L>;

  /**
   * the target id operator
   */
  targetId: IdOperator<L>;

  /**
   * the node datum operator
   */
  nodeDatum: IdNodeDatumOperator<N>;
}
/**
 * [object Object],[object Object],[object Object]
 */
declare type ConnectLinkDatum<Ops: ConnectOperators<>> = $FlowGen$If<
  $FlowGen$Assignable<Ops, ConnectOperators<mixed, L>>,
  L,
  empty
>;
export interface ConnectOperator<NodeDatum, Ops: ConnectOperators<NodeDatum>> {
  /**
   * [object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object]
   * @example ```typescript
   * const data = [ ["parent", "child"] ];
   * const create = connect();
   * const dag = create(data);
   * ```
   * @example ```json
   * [
   *   ["Eve", "Cain"],
   *   ["Eve", "Seth"],
   *   ["Seth", "Enos"],
   *   ["Seth", "Noam"],
   *   ["Eve", "Abel"],
   *   ["Eve", "Awan"]
   * ]
   * ```
   */
  <L: ConnectLinkDatum<Ops>>(data: $ReadOnlyArray<L>): Dag<NodeDatum, L>;

  /**
   * [object Object],[object Object],[object Object]
   */
  sourceId<NewId: IdOperator<>>(id: NewId): ConnectOperator<
    NodeDatum,
    Up<
      Ops,
      {
        /**
         * the new source id
         */
        sourceId: NewId,
        ...
      }
    >
  >;

  /**
   * Gets the current sourceId accessor.
   */
  sourceId(): $PropertyType<Ops, "sourceId">;

  /**
   * [object Object],[object Object],[object Object]
   */
  targetId<NewId: IdOperator<>>(id: NewId): ConnectOperator<
    NodeDatum,
    Up<
      Ops,
      {
        /**
         * the new target id
         */
        targetId: NewId,
        ...
      }
    >
  >;

  /**
   * Gets the current targetId accessor.
   */
  targetId(): $PropertyType<Ops, "targetId">;

  /**
   * [object Object],[object Object],[object Object]
   */
  nodeDatum<
    NewNodeDatum,
    NewNodeDatumOp: IdNodeDatumOperator<NewNodeDatum>
  >(data: {
    ...NewNodeDatumOp,
    ...IdNodeDatumOperator<NewNodeDatum>,
  }): ConnectOperator<
    NewNodeDatum,
    Up<
      Ops,
      {
        /**
         * the new node datum
         */
        nodeDatum: NewNodeDatumOp,
        ...
      }
    >
  >;

  /**
   * Get the current id node datum operator
   */
  nodeDatum(): $PropertyType<Ops, "nodeDatum">;

  /**
   * Sets the allowance for single nodes. If enabled and the source id equals
   * the target id, then a single node with no parents will be created.
   * Otherwise a self loop will be created which will result in an error. Note
   * only single nodes without parents or children need to be specified this
   * way, otherwise any other connection to a node will create it. (default: false)
   */
  single(val: boolean): ConnectOperator<NodeDatum, Ops>;

  /**
   * get the current single node setting.
   */
  single(): boolean;

  /**
   * Sets whether edges should be reversed to remove cycles
   *
   * If true, after creating the initial "graph" of nodes, an algorithm will
   * run to reverse enough edges to make the resulting data structure a valid
   * dag. It does this by reversing links in the original dag. Note that since
   * the structure is still a dag, old parents could now be positioned as
   * children, and instead the link will have `reversed` set to true. It is up
   * to the user to decide how to handle these links. (default: false)
   */
  decycle(val: boolean): ConnectOperator<NodeDatum, Ops>;

  /**
   * get the current decycle setting
   */
  decycle(): boolean;
}
/**
 * default interface for tuples that start with a string
 */
export interface ZeroString {
  /**
   * the zero property
   */
  +0: string;
}
/**
 * default interface for functions whose second element is a string
 */
export interface OneString {
  /**
   * the one property
   */
  +1: string;
}
/**
 * the default connect operator
 */
export type DefaultConnectOperator = ConnectOperator<
  ConnectDatum,
  {
    /**
     * the default source id operator
     */
    sourceId: IdOperator<ZeroString>,

    /**
     * the default target id operator
     */
    targetId: IdOperator<OneString>,

    /**
     * the default node datum operator
     */
    nodeDatum: IdNodeDatumOperator<ConnectDatum>,
    ...
  }
>;
/**
 * [object Object],[object Object],[object Object],[object Object]
 */
declare export function connect(...args: empty[]): DefaultConnectOperator;

/**
 * ***********
 * Hierarchy *
 * ***********
 */
/**
 * [object Object],[object Object],[object Object]
 */
export interface ChildrenOperator<NodeDatum> {
  (d: NodeDatum, i: number): $ReadOnlyArray<NodeDatum> | void;
}
/**
 * [object Object],[object Object],[object Object]
 */
export interface ChildrenDataOperator<NodeDatum, LinkDatum = mixed> {
  (d: NodeDatum, i: number): $ReadOnlyArray<[NodeDatum, LinkDatum]> | void;
}
/**
 * [object Object],[object Object],[object Object],[object Object],[object Object]
 */
export type WrappedChildrenOperator<
  NodeDatum,
  Children: ChildrenOperator<NodeDatum>
> = {
  /**
   * the wrapped children operator
   */
  wrapped: Children,
  ...
} & ChildrenDataOperator<NodeDatum, void>;

/**
 * [object Object],[object Object],[object Object],[object Object],[object Object]
 */
export type WrappedChildrenDataOperator<
  NodeDatum,
  ChildrenData: ChildrenDataOperator<NodeDatum>
> = {
  /**
   * the wrapped children data operator
   */
  wrapped: ChildrenData,
  ...
} & ChildrenOperator<NodeDatum>;

/**
 * the hierarchy operator operators
 */
export interface HierarchyOperators<NodeDatum, LinkDatum = mixed> {
  /**
   * the children operator
   */
  children: ChildrenOperator<NodeDatum>;

  /**
   * the children data operator
   */
  childrenData: ChildrenDataOperator<NodeDatum, LinkDatum>;
}
/**
 * a hierarchy operator with children
 */
export type ChildrenHierarchyOperator<
  NodeDatum,
  Children: ChildrenOperator<NodeDatum>
> = HierarchyOperator<
  NodeDatum,
  void,
  {
    /**
     * new children
     */
    children: Children,

    /**
     * new children data
     */
    childrenData: WrappedChildrenOperator<NodeDatum, Children>,
    ...
  }
>;
/**
 * a hierarchy operator with children data specified
 */
export type ChildrenDataHierarchyOperator<
  NodeDatum,
  LinkDatum,
  ChildrenData: ChildrenDataOperator<NodeDatum, LinkDatum>
> = HierarchyOperator<
  NodeDatum,
  LinkDatum,
  {
    /**
     * new children
     */
    children: WrappedChildrenDataOperator<NodeDatum, ChildrenData>,

    /**
     * new children data
     */
    childrenData: ChildrenData,
    ...
  }
>;
export interface HierarchyOperator<
  NodeDatum,
  LinkDatum,
  Ops: HierarchyOperators<NodeDatum, LinkDatum>
> {
  /**
   * [object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object]
   * @example ```typescript
   * const data = { id: "parent", children: [{ id: "child" }] };
   * const create = hierarchy();
   * const dag = create(data);
   * ```
   * @example [object Object],[object Object],[object Object]
   */
  (...data: $ReadOnlyArray<NodeDatum>): Dag<NodeDatum, LinkDatum>;

  /**
   * [object Object],[object Object],[object Object]
   */
  children<NewDatum, NewChildren: ChildrenOperator<NewDatum>>(ids: {
    ...NewChildren,
    ...ChildrenOperator<NewDatum>,
  }): ChildrenHierarchyOperator<NewDatum, NewChildren>;

  /**
   * [object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object]
   */
  children(): $PropertyType<Ops, "children">;

  /**
   * [object Object],[object Object],[object Object]
   */
  childrenData<
    NewDatum,
    NewLink,
    NewChildrenData: ChildrenDataOperator<NewDatum, NewLink>
  >(data: {
    ...NewChildrenData,
    ...ChildrenDataOperator<NewDatum, NewLink>,
  }): ChildrenDataHierarchyOperator<NewDatum, NewLink, NewChildrenData>;

  /**
   * [object Object],[object Object],[object Object],[object Object],[object Object]
   */
  childrenData(): $PropertyType<Ops, "childrenData">;

  /**
   * Specify if only roots should be passed in, if true, hierarchy will throw
   * an error if a non-root was passed initially. (default: true)
   */
  roots(val: boolean): HierarchyOperator<NodeDatum, LinkDatum, Ops>;

  /**
   * get the current roots value.
   */
  roots(): boolean;

  /**
   * [object Object],[object Object],[object Object]
   */
  decycle(val: boolean): HierarchyOperator<NodeDatum, LinkDatum, Ops>;

  /**
   * get the current decycle setting
   */
  decycle(): boolean;
}
/**
 * an object with children
 */
export interface HasChildren {
  /**
   * the children
   */
  +children?: $ReadOnlyArray<HasChildren> | void;
}
/**
 * the default hierarchy operator
 */
export type DefaultHierarchyOperator = ChildrenHierarchyOperator<
  HasChildren,
  ChildrenOperator<HasChildren>
>;
/**
 * [object Object],[object Object],[object Object],[object Object],[object Object]
 */
declare export function hierarchy(...args: empty[]): DefaultHierarchyOperator;

/**
 * **********
 * Stratify *
 * **********
 */
/**
 * [object Object],[object Object],[object Object]
 */
export interface ParentIdsOperator<NodeDatum = empty> {
  (d: NodeDatum, i: number): $ReadOnlyArray<string> | void;
}
/**
 * the node datum of a parent ids operator
 */
export type ParIdsNodeDatum<P: ParentIdsOperator<>> = $FlowGen$If<
  $FlowGen$Assignable<P, ParentIdsOperator<N>>,
  N,
  empty
>;
/**
 * [object Object],[object Object],[object Object]
 */
export interface ParentDataOperator<NodeDatum = empty, LinkDatum = mixed> {
  (d: NodeDatum, i: number): $ReadOnlyArray<[string, LinkDatum]> | void;
}
/**
 * the node datum of a parent data operator
 */
export type ParDataNodeDatum<P: ParentDataOperator<>> = $FlowGen$If<
  $FlowGen$Assignable<P, ParentDataOperator<N>>,
  N,
  empty
>;
declare type StratifyNodeDatum<Ops: StratifyOperators<>> = $FlowGen$If<
  $FlowGen$Assignable<Ops, StratifyOperators<N>>,
  N,
  empty
>;
/**
 * [object Object],[object Object],[object Object],[object Object],[object Object]
 */
export type WrappedParentIdsOperator<ParentIds: ParentIdsOperator<>> = {
  /**
   * the wrapped parent ids operator
   */
  wrapped: ParentIds,
  ...
} & ParentDataOperator<ParIdsNodeDatum<ParentIds>, void>;

/**
 * [object Object],[object Object],[object Object],[object Object],[object Object]
 */
export type WrappedParentDataOperator<ParentData: ParentDataOperator<>> = {
  /**
   * the wrapped parent data operator
   */
  wrapped: ParentData,
  ...
} & ParentIdsOperator<ParDataNodeDatum<ParentData>>;

/**
 * the operators for the stratify operator
 */
export interface StratifyOperators<NodeDatum = empty, LinkDatum = mixed> {
  /**
   * the id operator
   */
  id: IdOperator<NodeDatum>;

  /**
   * the parent ids operator
   */
  parentIds: ParentIdsOperator<NodeDatum>;

  /**
   * the parent data operator
   */
  parentData: ParentDataOperator<NodeDatum, LinkDatum>;
}
/**
 * the id stratify operator
 */
export type IdsStratifyOperator<
  Ops: StratifyOperators<>,
  ParentIds: ParentIdsOperator<>
> = StratifyOperator<
  void,
  Up<
    Ops,
    {
      /**
       * new parent ids
       */
      parentIds: ParentIds,

      /**
       * new parent data
       */
      parentData: WrappedParentIdsOperator<ParentIds>,
      ...
    }
  >
>;
/**
 * a stratify operator with parent data specified
 */
export type DataStratifyOperator<
  LinkDatum,
  Ops: StratifyOperators<>,
  ParentData: ParentDataOperator<empty, LinkDatum>
> = StratifyOperator<
  LinkDatum,
  Up<
    Ops,
    {
      /**
       * new parent data
       */
      parentData: ParentData,

      /**
       * new parent ids
       */
      parentIds: WrappedParentDataOperator<ParentData>,
      ...
    }
  >
>;
export interface StratifyOperator<
  LinkDatum,
  Ops: StratifyOperators<empty, LinkDatum>
> {
  /**
   * [object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object]
   * @example ```typescript
   * const data = [{ id: "parent" }, { id: "child", parents: ["parent"] }];
   * const create = stratify().parentIds(({ parents }) => parents);
   * const dag = create(data);
   * ```
   * @example ```json
   * [
   *   {
   *     "id": "Eve"
   *   },
   *   {
   *     "id": "Cain",
   *     "parentIds": ["Eve"]
   *   },
   *   {
   *     "id": "Seth",
   *     "parentIds": ["Eve"]
   *   },
   *   {
   *     "id": "Enos",
   *     "parentIds": ["Seth"]
   *   },
   *   {
   *     "id": "Noam",
   *     "parentIds": ["Seth"]
   *   },
   *   {
   *     "id": "Abel",
   *     "parentIds": ["Eve"]
   *   },
   *   {
   *     "id": "Awan",
   *     "parentIds": ["Eve"]
   *   },
   *   {
   *     "id": "Enoch",
   *     "parentIds": ["Eve"]
   *   },
   *   {
   *     "id": "Azura",
   *     "parentIds": ["Eve"]
   *   }
   * ]
   * ```
   */
  <N: StratifyNodeDatum<Ops>>(data: $ReadOnlyArray<N>): Dag<N, LinkDatum>;

  /**
   * [object Object],[object Object],[object Object]
   */
  id<NewId: IdOperator<>>(id: NewId): StratifyOperator<
    LinkDatum,
    Up<
      Ops,
      {
        /**
         * the new id
         */
        id: NewId,
        ...
      }
    >
  >;

  /**
   * Gets the current id accessor.
   */
  id(): $PropertyType<Ops, "id">;

  /**
   * [object Object],[object Object],[object Object]
   */
  parentIds<NewParentIds: ParentIdsOperator<>>(
    ids: NewParentIds
  ): IdsStratifyOperator<Ops, NewParentIds>;

  /**
   * [object Object],[object Object],[object Object],[object Object],[object Object]
   */
  parentIds(): $PropertyType<Ops, "parentIds">;

  /**
   * [object Object],[object Object],[object Object]
   */
  parentData<
    NewLinkDatum,
    NewParentData: ParentDataOperator<empty, NewLinkDatum>
  >(data: {
    ...NewParentData,
    ...ParentDataOperator<empty, NewLinkDatum>,
  }): DataStratifyOperator<NewLinkDatum, Ops, NewParentData>;

  /**
   * [object Object],[object Object],[object Object],[object Object],[object Object]
   */
  parentData(): $PropertyType<Ops, "parentData">;

  /**
   * Sets whether edges should be reversed to remove cycles
   *
   * If true, after creating the initial "graph" of nodes, an algorithm will
   * run to reverse enough edges to make the resulting data structure a valid
   * dag. It does this by reversing links in the original dag. Note that since
   * the structure is still a dag, old parents could now be positioned as
   * children, and instead the link will have `reversed` set to true. It is up
   * to the user to decide how to handle these links. (default: false)
   */
  decycle(val: boolean): StratifyOperator<LinkDatum, Ops>;

  /**
   * get the current decycle setting
   */
  decycle(): boolean;
}
/**
 * default interface for types with an id
 */
export interface HasId {
  /**
   * the id
   */
  +id: string;
}
/**
 * default interface for data types with parent ids
 */
export interface HasParentIds {
  /**
   * the parent ids
   */
  +parentIds?: $ReadOnlyArray<string> | void;
}
/**
 * the default stratify operator
 */
export type DefaultStratifyOperator = IdsStratifyOperator<
  {
    /**
     * the id operator
     */
    id: IdOperator<HasId>,

    /**
     * the parent id operator
     */
    parentIds: ParentIdsOperator<>,

    /**
     * the parent data operator
     */
    parentData: ParentDataOperator<>,
    ...
  },
  ParentIdsOperator<HasParentIds>
>;
/**
 * [object Object],[object Object],[object Object],[object Object],[object Object]
 */
declare export function stratify(...args: empty[]): DefaultStratifyOperator;
